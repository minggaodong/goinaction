# Chapter4

## Array
声明数组时需要指定内部存储的数据的类型，以及需要存储的元素的数量，这个数量也称为数组的长度。

### 声明和初始化
```go
var array1 [5]int
array2 := [5]int{10, 20, 30, 40, 50}
array3 := [...]int{10, 20, 30, 40, 50}
array4 := [5]int{1: 10, 2: 20}
```

### 使用数组
要访问数组里某个单独元素，使用`[]`运算符。如
```go
array := [5]int{10, 20, 30, 40, 50}
fmt.Println(array[2]) // 输出 30
```

数组变量的类型包括数组长度和每个元素的类型。只有这两部分都相同的数组，才是类型相同的数组，才能互相赋值。

### 多维数组
```go
var array1 [4][2]int
array2 := [4][2]int{{10, 11}, {20, 21}, {30, 31}, {40, 41}}
array3 := [4][2]int{1: {20, 21}, 3: {40, 41}}
array4 := [4][2]int{1: {0: 20}, 3: {1: 41}}
fmt.Println(array2[0][0]) // 输出 10
```

### 数组参数
根据内存和性能来看，在函数间传递数组是一个开销很大的操作。在函数之间传递变量时， 总是以值的方式传递的。
如果这个变量是一个数组，意味着整个数组，不管有多长，都会完整复制，并传递给函数。

更有效的方式是传入指向数组的指针

```go
var array [1e6]int

func foo1(array [1e6]int){
}

func foo2(array *[1e6]int){
}

foo1(array)
foo2(&array)
```

## Slice
切片是一种数据结构，这种数据结构便于使用和管理数据集合。切片是围绕动态数组的概念构建的，可以按需自动增长和缩小。
切片的动态增长是通过内置函数 append 来实现的。这个函数可以快速且高效地增长切片。
还可以通过对切片再次切片来缩小一个切片的大小。因为切片的底层内存也是在连续块中分配的，
所以切片还能获得索引、迭代以及为垃圾回收优化的好处。

切片有 3 个字段的数据结构，这些数据结构包含 Go 语言需要操作底层数组的元数据。
这 3 个字段分别是指向底层数组的指针、切片访问的元素的个数(即长度)和切片允许增长到的元素个数(即容量)。

![切片内部实现](https://github.com/wangzz719/goinaction/tree/master/chapter4/slice.png)